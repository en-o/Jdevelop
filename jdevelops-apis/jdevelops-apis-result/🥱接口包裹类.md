> 规范的返回对象有利于减少前后端的摩擦
> 强制让项目返回统一的结构

# 依赖
```xml
<dependency>
    <groupId>cn.tannn.jdevelops</groupId>
    <artifactId>jdevelops-apis-result</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```
# 主要结构
## Request
### 分页

### 排序

### 分页排序

## Response
### 常规返回

### 分页返回

# 隐式强制返回包裹类
## 设置
```properties
jdevelops.api.result.enabled=true
```
## 接口验证
```java
package cn.tannn.demo.jdevelops.apisresult;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * 隐式强制返回包裹类：jdevelops.api.result.enabled=true
 * <p> prod 配置文件
 *
 * @author <a href="https://tannn.cn/">tan</a>
 * @date 2024/5/9 上午9:38
 */
@RestController
@RequestMapping("implicit")
public class ImplicitController {


    @GetMapping("/string")
    public String string(){
        return "测试隐式添加包裹类";
    }


    @GetMapping("/list")
    public List<String> list(){
        return Collections.singletonList("测试隐式添加包裹类");
    }

    @GetMapping("/map")
    public Map<String,String> map(){
        return Collections.singletonMap("tan","测试隐式添加包裹类");
    }

    @GetMapping("/bean")
    public User bean(){
        return new User("tan",1,2);
    }
}

```
## 返回结果
```http
### string
GET http://localhost:8080/implicit/string

HTTP/1.1 200 
version: 1.0
Content-Type: application/json
Transfer-Encoding: chunked
Date: Thu, 09 May 2024 01:58:14 GMT

{
  "code": 200,
  "message": "成功",
  "ts": 1715219894651,
  "data": "测试隐式添加包裹类",
  "success": true
}

### list
GET http://localhost:8080/implicit/list

HTTP/1.1 200 
version: 1.0
Content-Type: application/json
Transfer-Encoding: chunked
Date: Thu, 09 May 2024 02:04:05 GMT

{
  "code": 200,
  "message": "成功",
  "ts": 1715220245051,
  "data": [
    "测试隐式添加包裹类"
  ],
  "success": true
}


### map
GET http://localhost:8080/implicit/map

HTTP/1.1 200 
version: 1.0
Content-Type: application/json
Transfer-Encoding: chunked
Date: Thu, 09 May 2024 02:02:10 GMT

{
  "code": 200,
  "message": "成功",
  "ts": 1715220130911,
  "data": {
    "tan": "测试隐式添加包裹类"
  },
  "success": true
}

### bean
GET http://localhost:8080/implicit/bean

HTTP/1.1 200
version: 1.0
Content-Type: application/json
Transfer-Encoding: chunked
Date: Thu, 09 May 2024 01:58:17 GMT

{
  "code": 200,
  "message": "成功",
  "ts": 1715219897320,
  "data": [
    "测试隐式添加包裹类"
  ],
  "success": true
}
```
# 重置默认包裹类
> 自定义自己的类对象，这个可以作用在**全局异常**和**隐式强制**上


## 构建自己想要的结果集
```java
package cn.tannn.demo.jdevelops.apisresult.reset;


import cn.tannn.jdevelops.result.exception.ExceptionCode;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.io.Serializable;

/**
 * 全局结果集
 *
 * @author tn
 * @version 1
 * @date 2020/6/8 17:28
 */
@Getter
@Setter
@ToString
public class ReplaceResultVO<T> implements Serializable {

    private static final long serialVersionUID = -7719394736046024902L;

    /**
     * 返回结果状态码
     */
    private Integer zhuangTaiMa;

    /**
     * 返回消息
     */
    private String xiaoXi;

    /**
     * 数据
     */
    private T sJu;



    public static <T> ReplaceResultVO<T> success() {
        ReplaceResultVO<T> resultVO = new ReplaceResultVO<>();
        resultVO.setZhuangTaiMa(200);
        resultVO.setXiaoXi("success");
        return resultVO;
    }



    public static <T> ReplaceResultVO<T> fail() {
        ReplaceResultVO<T> resultVO = new ReplaceResultVO<>();
        resultVO.setZhuangTaiMa(500);
        resultVO.setXiaoXi("fail");
        return resultVO;
    }

    public static <T> ReplaceResultVO<T> fail(String message) {
        ReplaceResultVO<T> resultVO = new ReplaceResultVO<>();
        resultVO.setZhuangTaiMa(500);
        resultVO.setXiaoXi(message);
        return resultVO;
    }

    public static <T> ReplaceResultVO success( T data) {
        ReplaceResultVO<T> resultVO = new ReplaceResultVO<>();
        resultVO.setZhuangTaiMa(200);
        resultVO.setSJu(data);
        return resultVO;
    }
    public static <T> ReplaceResultVO result(int code, String message) {
        ReplaceResultVO<T> resultVO = new ReplaceResultVO<>();
        resultVO.setZhuangTaiMa(code);
        resultVO.setXiaoXi(message);
        return resultVO;
    }
    public static <T> ReplaceResultVO result(int code, String message,T data) {
        ReplaceResultVO<T> resultVO = new ReplaceResultVO<>();
        resultVO.setZhuangTaiMa(code);
        resultVO.setXiaoXi(message);
        resultVO.setSJu(data);
        return resultVO;
    }

    public static <T> ReplaceResultVO result(ExceptionCode result, T data) {
        ReplaceResultVO<T> resultVO = new ReplaceResultVO<>();
        resultVO.setZhuangTaiMa(result.getCode());
        resultVO.setXiaoXi(result.getMessage());
        resultVO.setSJu(data);
        return resultVO;
    }


    public static <T> ReplaceResultVO result(ExceptionCode result) {
        ReplaceResultVO<T> resultVO = new ReplaceResultVO<>();
        resultVO.setZhuangTaiMa(result.getCode());
        resultVO.setXiaoXi(result.getMessage());
        return resultVO;
    }
}

```
## 重新实现ExceptionResult
> 1. 不想用了注释掉这个 `@Component`
> 2. `ExceptionResult`里所有的方法都要重写，要不然有些地方可能不生效

```java
package cn.tannn.demo.jdevelops.apisresult.reset;


import cn.tannn.jdevelops.result.exception.ExceptionCode;
import cn.tannn.jdevelops.result.exception.ExceptionResult;
import org.springframework.stereotype.Component;

/**
 * 自定义返回包装类
 * @author tn
 * @date 2021-01-20 10:50
 */
@Component("exceptionResult")
public class CustomResult implements ExceptionResult<ReplaceResultVO> {


    @Override
    public ReplaceResultVO result(ExceptionCode resultCode) {
        return ReplaceResultVO.result(resultCode);
    }

    @Override
    public ReplaceResultVO result(int code, String message) {
        return ReplaceResultVO.result(code, message);
    }

    @Override
    public ReplaceResultVO result(int code, String message, Object data) {
        return ReplaceResultVO.result(code, message , data);
    }

    @Override
    public ReplaceResultVO result(ExceptionCode resultCode, Object data) {
        return ReplaceResultVO.result(resultCode, data);
    }

    @Override
    public ReplaceResultVO success() {
        return ReplaceResultVO.success();
    }

    @Override
    public ReplaceResultVO success(Object data) {
        return ReplaceResultVO.success(data);
    }

    @Override
    public ReplaceResultVO fail(String message) {
        return ReplaceResultVO.fail(message);
    }

    @Override
    public ReplaceResultVO fail() {
        return ReplaceResultVO.fail();
    }
}

```
## 效果展示
> 用上面的隐式强制返回包裹类的接口测试

```http
GET http://localhost:8080/implicit/string

HTTP/1.1 200 
version: 1.0
Content-Type: application/json
Transfer-Encoding: chunked
Date: Thu, 09 May 2024 02:24:45 GMT

{
  "zhuangTaiMa": 200,
  "xiaoXi": null,
  "sju": "测试隐式添加包裹类"
}
```

# 常用工具类
> 具体使用请看单元测试

## AssertUtils
## ListTo
## PagingSortedUtil
## StrUtils
## UUIDUtils
## ColumnUtil
```java
// 测试注解改字段名
assertEquals(ColumnUtil.getFieldName(Apply::getMySex,true),"sex");
// 测试转驼峰
assertEquals(ColumnUtil.getFieldName(Help::getMyTest,true),"my_test");
// 正常Key
assertEquals(ColumnUtil.getFieldName(Help::getMyTest),"myTest");
```
## BeanCopyUtil
